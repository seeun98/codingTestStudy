# 프로그래머스_평행 <br>
## 2022-10-26

https://school.programmers.co.kr/learn/courses/30/lessons/120875 

### 조합으로 푼 풀이
```Java
import java.util.*;

class Solution {
  public static int [] output; //조합으로 뽑힌 배열 인덱스 저장
  static boolean visited[] = new boolean[4]; //방문했던 인덱스 true, false 저장
  public static int n, r; //nCr -> 4C2
  public static int result = 0; //기울기 평행이면 1, 아니면 0
    
    public static void combi(int cnt, int start, int[][] dots) {
        if (cnt == r){ //0부터 시작한 cnt가 r을 만나면 반환 -> 0번째, 1번째 모두 값 있는 상태
            //1. 뽑힌 점들의 x,y
            int firstX = dots[output[0]][0];
            int secondX = dots[output[1]][0];
            int firstY = dots[output[0]][1];
            int secondY = dots[output[1]][1];
            System.out.println(firstX + "," + secondX + "," + firstY + "," + secondY);
            
            int X1 = Math.abs(firstX - secondX);
            int Y1 = Math.abs(firstY - secondY);
            
            //2. 안뽑힌 점들의 x,y
            List<Integer> rest = new ArrayList<>();
            
            for(int i =0;i<4;i++){
                if(!visited[i]){ //안뽑힌 것들
                    //System.out.print(i+" ");
                    rest.add(i);
                }
            }
         
            int thirdX = dots[rest.get(0)][0];
            int forthX = dots[rest.get(1)][0];
            int thirdY = dots[rest.get(0)][1];
            int forthY = dots[rest.get(1)][1];

            int X2 = Math.abs(thirdX-forthX);
            int Y2 = Math.abs(thirdY-forthY);
            
            if ((Y1/(double)X1) == (Y2/(double)X2)) result = 1;
            
            // if(((double)(X1/X2) != 0) && ((double)(Y1/Y2) != 0)) {
            //     if((double)(X1/X2) == (double)(Y1/Y2)){
            //         result = 1;
            //         return;
            //     }
            // }
            // if (result == 1) return;
            // else result = 0;
            
        return;
        }
        
        for(int i = start; i < n; i++){
            output[cnt] = i;
            visited[i] = true;
          //System.out.println(cnt + "," + i);
            combi(cnt+1, i+1, dots);
            visited[i] = false;



        }
    }
    
    
    public int solution(int[][] dots) {
        
        Arrays.fill(visited, false);
        n = 4;
        r = 2;
        output = new int[2]; // 뽑은 2개 인덱스 저장
        combi(0, 0, dots);
        System.out.println(result);
        return result;
    }    
    
}
```


### 이중 for문
```Java
import java.util.*;

class Solution {
    int result = 0;
    public int solution(int[][] dots) {
        int firstX, firstY;
        int secondX, secondY;
        int thirdX, thirdY;
        int forthX, forthY;
        
        List<Integer> notVisited = new ArrayList<>();
        boolean visited[] = new boolean[4]; //뽑힌 인덱스인지 확인
        Arrays.fill(visited, false); //false로 초기화
        
        POS : for(int i = 0; i < 4; i++){ 
                for(int j = i+1; j < 4; j++){
                    visited[i] = true; //뽑힌 인덱스 true
                    visited[j] = true;
                    
                    firstX = dots[i][0];
                    firstY = dots[i][1];
                    secondX = dots[j][0];
                    secondY = dots[j][1];
                    
                    for(int k = 0; k < 4; k++){
                        if(!visited[k]){
                            notVisited.add(k); //안뽑힌 것은 list로 저장
                        }
                    }
                    
                    thirdX = dots[notVisited.get(0)][0];
                    thirdY = dots[notVisited.get(0)][1];
                    forthX = dots[notVisited.get(1)][0];
                    forthY = dots[notVisited.get(1)][1];
                    
                    int X1 = Math.abs(firstX - secondX);
                    int Y1 = Math.abs(firstY - secondY);
                    
                    int X2 = Math.abs(thirdX - forthX);
                    int Y2 = Math.abs(thirdY - forthY);
                    
                    
                    if ((Y1/(double)X1) == (Y2/(double)X2)) {
                        result = 1;
                        break POS;
                    }
                    Arrays.fill(visited, false); //끝나면 false로 다시 초기화
                    notVisited.clear(); //안해주면 notVisited에 계속 쌓임
            }
            
        }  
        
        System.out.println(result);
        return result;
    }
}
```





