## [프로그래머스] 게임 맵 최단 거리

### solution
```java
import java.util.*;

class Solution {
    public int solution(int[][] maps) {
        int answer = 0;
        
        //1. maps와 같은 visited 하나 만들기 
        //2. dx, dy 만들기
        boolean[][] visited = new boolean[maps.length][maps[0].length];
        
        for(int i = 0; i < maps.length; i++){
            for(int j = 0; j < maps[i].length; j++){
                visited[i][j] = false;
            }
        }
        
        
        int[] dx = {-1, 0, 1, 0};
        int[] dy = {0, 1, 0, -1};
        
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0,0});
        
        visited[0][0] = true;
        
        while(!q.isEmpty()){
            int[] poll = q.poll();
            int x = poll[0];
            int y = poll[1];
           
           
                              
            for(int d = 0; d < 4; d++){
                int nx = x + dx[d];
                int ny = y + dy[d];
                //System.out.println("nx : " + nx + ",ny : " + ny);
                if(nx < 0 || nx >= maps.length || ny < 0 || ny >= maps[0].length){
                        continue;
                }
                if(visited[nx][ny] || maps[nx][ny] == 0) continue;
                
                
                visited[nx][ny] = true;
                maps[nx][ny] = maps[x][y] + 1;
                q.add(new int[]{nx, ny});
            }
            
        }
        
        
        
        if(maps[maps.length-1][maps[0].length-1] != 0 && visited[maps.length-1][maps[0].length-1]) answer = maps[maps.length-1][maps[0].length-1];
        else answer = -1;
        return answer;
    }
}
```

### 참고
- 개수 세기 -> 여기서 인접한데 그냥 넣을떄 ++ 하면 cnt 잘못됨 
- maps 자체에서 maps[nx][ny] = maps[x][y] + 1;